# クラス構造　Lv3

----

### 教材制作者へ

特に指示の無い場合は**入力問題**とする。

----

## Q1

Printerクラスをインスタンス化して実行するプログラムになるよう、空欄を埋めなさい。また、実行結果も答えなさい。

```java
class Main {
  public static void main(String[] args) {
    [  1  ] [  2  ];
  }
}

class Printer {
  [  3  ] {
    int a = 10;
    int b = 8;
    System.out.println("Ans:" + a + b);
  }
}
```
```
実行結果
[  4  ]
```

### ヒント1

プログラムを部品に分けるためには、実行用のクラスとは別のクラスを作る。

部品用のクラスを使うためには、クラスの内容をメモリ上に用意する「インスタンス化」を行う。

インスタンス化には、new 演算子を用いる。

```java
class Foo {
  // 部品クラス
}
```

```java
// Fooクラスをインスタンス化する
new Foo();
```

### ヒント2

部品クラスがインスタンス化されたときの処理は、コンストラクタに記載する。

コンストラクタは、クラス名と同じ名前のブロックにする。

```java
class Foo {
  Foo() {
    // クラス名と同じ名前のブロックがコンストラクタ
    // インスタンス化された時の処理を記載する
  }
}
```

### ヒント3

この設問では、main部分が実行されると、Printerクラスがインスタンス化される。

インスタンス化されると、Printerクラスのコンストラクタ Printer() が実行される。

コンストラクタでは、整数a,bの足し算の結果を文字列"Ans:"に加え、標準出力に表示する。

答え

1. new
2. Printer()
3. Printer()
4. Ans:108


## Q2

Inputterクラスをインスタンス化して実行するプログラムになるよう、空欄を埋めなさい。

また、プログラムの実行後に 5 を入力した場合の実行結果を答えなさい。

```java
class Main {
  public static void main(String[] args) {
    [  1  ] [  2  ];
  }
}

class Inputter {
  [  3  ] {
    Scanner scanner = new Scanner(System.in);
    int num = scanner.nextInt();
    scanner.close();
    System.out.println("Ans:" + num * num);
  }
}
```

```
実行結果
5
[  4  ]
```

### ヒント1

プログラムを部品に分けるためには、実行用のクラスとは別のクラスを作る。

部品用のクラスを使うためには、クラスの内容をメモリ上に用意する「インスタンス化」を行う。

インスタンス化には、new 演算子を用いる。

```java
class Foo {
  // 部品クラス
}
```

```java
// Fooクラスをインスタンス化する
new Foo();
```

### ヒント2

部品クラスがインスタンス化されたときの処理は、コンストラクタに記載する。

コンストラクタは、クラス名と同じ名前のブロックにする。

```java
class Foo {
  Foo() {
    // クラス名と同じ名前のブロックがコンストラクタ
    // インスタンス化された時の処理を記載する
  }
}
```

### ヒント3

この設問では、main部分が実行されると、Inputterクラスがインスタンス化される。

インスタンス化されると、Inputterクラスのコンストラクタ Inputter() が実行される。

コンストラクタでは、標準入力（キーボード）から入力された整数numを自乗し、文字列"Ans:"に加え、標準出力に表示している。

答え

1. new
2. Inputter()
3. Inputter()
4. Ans:25


## Q3

プログラムが実行結果の通りになるように、空欄を埋めなさい。

```java
class Main {
  public static void main(String[] args) {
    [  1  ] [  2  ];
    [  3  ] [  4  ];
  }
}

class ClassA {
  ClassA() {
    System.out.println("Aをインスタンス化");
  }

}

class ClassB {
  ClassB() {
    System.out.println("Bをインスタンス化");
  }
}
```

```
実行結果
Bをインスタンス化
Aをインスタンス化
```

### ヒント1

プログラムを部品に分けるためには、実行用のクラスとは別のクラスを作る。

部品用のクラスを使うためには、クラスの内容をメモリ上に用意する「インスタンス化」を行う。

インスタンス化には、new 演算子を用いる。

```java
class Foo {
  // 部品クラス
}
```

```java
// Fooクラスをインスタンス化する
new Foo();
```

### ヒント2

部品クラスがインスタンス化されたときの処理は、コンストラクタに記載する。

コンストラクタは、クラス名と同じ名前のブロックにする。

```java
class Foo {
  Foo() {
    // クラス名と同じ名前のブロックがコンストラクタ
    // インスタンス化された時の処理を記載する
  }
}
```

### ヒント3

実行結果をみると、ClassBのコンストラクタ ClassB() の処理の後に、ClassAのコンストラクタ ClassA() の処理が行われていることがわかる。

したがって、インスタンス化は、ClassB、ClassAの順番で行われている。

```java
new ClassB();
new ClassA();
```

答え

1. new
2. ClassB
3. new
4. ClassA


## Q3

プログラムが実行結果の通りになるように、空欄を埋めなさい。

```java
class Main {
  public static void main(String[] args) {
    [  1  ] [  2  ];
    [  3  ] [  4  ];
  }
}

class ClassA {
  ClassA() {
    System.out.println("Aをインスタンス化");
  }

}

class ClassB {
  ClassB() {
    System.out.println("Bをインスタンス化");
  }
}
```

```
実行結果
Aをインスタンス化
Bをインスタンス化
```

### ヒント1

プログラムを部品に分けるためには、実行用のクラスとは別のクラスを作る。

部品用のクラスを使うためには、クラスの内容をメモリ上に用意する「インスタンス化」を行う。

インスタンス化には、new 演算子を用いる。

```java
class Foo {
  // 部品クラス
}
```

```java
// Fooクラスをインスタンス化する
new Foo();
```

### ヒント2

部品クラスがインスタンス化されたときの処理は、コンストラクタに記載する。

コンストラクタは、クラス名と同じ名前のブロックにする。

```java
class Foo {
  Foo() {
    // クラス名と同じ名前のブロックがコンストラクタ
    // インスタンス化された時の処理を記載する
  }
}
```

### ヒント3

実行結果をみると、ClassAのコンストラクタ ClassA() の処理の後に、ClassBのコンストラクタ ClassB() の処理が行われていることがわかる。

したがって、インスタンス化は、ClassA、ClassBの順番で行われている。

```java
new ClassA();
new ClassB();
```

答え

1. new
2. ClassA
3. new
4. ClassB

## Q5

プログラムの空欄を埋め、実行結果を答えなさい。

```java
class Main {
  public static void main(String[] args) {
  	new Add();
  	new Multi();
  }
}

class [  1  ] {
  Add() {
  	int a = 5;
  	int b = 4;
  	System.out.println(a + b);
  }
}

class [  2  ] {
  Multi() {
  	int a = 3;
  	int b = 2;
  	System.out.println(a * b);
  }
}
```

```
実行結果
[  3  ]
[  4  ]
```

### ヒント1

プログラムを部品に分けるためには、実行用のクラスとは別のクラスを作る。

部品用のクラスを使うためには、クラスの内容をメモリ上に用意する「インスタンス化」を行う。

インスタンス化には、new 演算子を用いる。

```java
class Foo {
  // 部品クラス
}
```

```java
// Fooクラスをインスタンス化する
new Foo();
```

### ヒント2

部品クラスがインスタンス化されたときの処理は、コンストラクタに記載する。

コンストラクタは、クラス名と同じ名前のブロックにする。

```java
class Foo {
  Foo() {
    // クラス名と同じ名前のブロックがコンストラクタ
    // インスタンス化された時の処理を記載する
  }
}
```

### ヒント3

Add() コンストラクタ、Multi() コンストラクタがあることから、それらのクラス名はそれぞれ Add クラスと Multi クラスであることが推測できる。

mainブロックでは、 Addクラス、Multiクラスの順でインスタンス化が行われていることから、 Add() コンストラクタ、Multi() コンストラクタの順で実行される。

ブロックの中で宣言される変数は、同じ名前であっても他のブロックに影響しない。したがってAdd()コンストラクタのブロックでは 5+4 , Multi()コンストラクタのブロックでは 3*2 の計算が行われる。

答え

1. Add
2. Multi
3. 9
4. 6


## Q6 

下のプログラムを作成し、コマンドを実行した。結果について正しいものを選びなさい。

```java
class Main {
  public static void main(String[] args) {
    int a = 5;
    int b = 4;
    new Addition();
  }
}

class Add {
  Add() {
    System.out.println(a + b);
  }
}
```

1. コンパイルすることができない
2. コンパイルして実行すると、エラーが生じる
3. 実行結果は 0 と表示される
4. 実行結果は 9 と表示される
5. 実行結果は a + b と表示される

答え　[    ]

### ヒント1

プログラムを部品に分けるためには、実行用のクラスとは別のクラスを作る。

部品用のクラスを使うためには、クラスの内容をメモリ上に用意する「インスタンス化」を行う。

インスタンス化には、new 演算子を用いる。

```java
class Foo {
  // 部品クラス
}
```

```java
// Fooクラスをインスタンス化する
new Foo();
```

### ヒント2

部品クラスがインスタンス化されたときの処理は、コンストラクタに記載する。

コンストラクタは、クラス名と同じ名前のブロックにする。

```java
class Foo {
  Foo() {
    // クラス名と同じ名前のブロックがコンストラクタ
    // インスタンス化された時の処理を記載する
  }
}
```

### ヒント3

ブロックの中で宣言される変数は、同じ名前であっても他のブロックに影響しない。

Addクラスの Add() コンストラクタでは、そのブロックで宣言されていない変数a,bを使って計算を行おうとしている。
（Mainクラスのmainブロックのa,bは使用されない）

宣言されていない変数の利用は、プログラムの文法として誤っており、コンパイルすることはできない。

答え：1


## Q7

下のプログラムを作成し、コマンドを実行した。結果について正しいものを選びなさい。

```java
class Main {
  public static void main(String[] args) {
    new Add();
  }
}

class Add {
  Add() {
    int a = 3;
    int b = 2;
    System.out.println(a + b);
  }
}
```

```
実行コマンド
javac Main.java Add.java
java Add
```

1. コンパイルすることができず、プログラムは実行されない
2. 実行すると、エラーが生じる
3. 実行結果は 0 と表示される
4. 実行結果は 5 と表示される
5. 実行結果は a + b と表示される

答え　[    ]

### ヒント1

プログラムを部品に分けるためには、実行用のクラスとは別のクラスを作る。

部品用のクラスを使うためには、クラスの内容をメモリ上に用意する「インスタンス化」を行う。

インスタンス化には、new 演算子を用いる。

```java
class Foo {
  // 部品クラス
}
```

```java
// Fooクラスをインスタンス化する
new Foo();
```

### ヒント2

部品クラスがインスタンス化されたときの処理は、コンストラクタに記載する。

コンストラクタは、クラス名と同じ名前のブロックにする。

```java
class Foo {
  Foo() {
    // クラス名と同じ名前のブロックがコンストラクタ
    // インスタンス化された時の処理を記載する
  }
}
```

### ヒント3

Javaのプログラムは、mainブロックから実行される。

この問題の実行コマンドは、Addクラスから動作させようとしているが、Addクラスにはmainブロックは存在しない。

このような場合はプログラムを実行すると、エラーが生じてしまう。

答え：2


## Q8

下のプログラムについて、正しいものを選びなさい。

```java
class Main {
  public static void main(String[] args) {
    new Add();
  }
}

class Add {
  Add() {
    int a = 5;
    int b = 4;
    System.out.println(a + b);
  }
}

class Multi {
  Multi() {
    int a = 5;
    int b = 4;
    System.out.println(a * b);
  }
}
```

```
実行コマンド
javac Main.java Add.java Multi.java
java Main
```

1. コンパイルすることができない
2. コンパイルして実行すると、エラーが生じる
3. 実行結果は 9 と表示される
4. 実行結果は 9 20 の順に表示される
5. 実行結果は 20 9 の順に表示される

答え　[    ]

### ヒント1

プログラムを部品に分けるためには、実行用のクラスとは別のクラスを作る。

部品用のクラスを使うためには、クラスの内容をメモリ上に用意する「インスタンス化」を行う。

```java
class Foo {
  // 部品クラス
}

// Fooクラスをインスタンス化する
new Foo();
```

### ヒント2

部品クラスがインスタンス化されたときの処理は、コンストラクタに記載する。

コンストラクタは、クラス名と同じ名前のブロックにする。

```java
class Foo {
  Foo() {
    // クラス名と同じ名前のブロックがコンストラクタ
    // インスタンス化された時の処理を記載する
  }
}
```

### ヒント3

プログラムが実行されるmainブロックでは、Addクラスのみインスタンス化している。

クラスが存在してコンパイルされていたとしても、プログラムの中でインスタンス化されない限り、利用されることはない。つまり、設問のプログラムではMulti()コンストラクタの内容は実行されない。

プログラムの文法に誤りがある場合は、コンパイルエラーが生じる可能性はある。しかし、設問のプログラムに文法が誤りとなる部分は見あたらない。

したがって、Add()コンストラクタの処理結果である 9 のみが表示される。

答え：3
